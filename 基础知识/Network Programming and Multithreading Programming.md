## `select`函数
> * 函数原型：`int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout)`
> * 头文件：`#include<sys/seletct.h>`
> * 函数返回值：若有就绪的描述符，则返回就绪描述符个数；若超时，则返回0；如出错返回-1。
> * 参数：
>   > * `timeout`用于指定等待的时间。若指针为空，则表示**永远等下去**；若为0，则表示不等待，**轮询**；否则为等待一个固定的时间，**超时返回**。在等待期间，**会被进程所捕获的信号中断**，并返回**EINTR**错误。
>   > * `readset`、`writeset`和`exceptset`分别表示测试的描述符集，若置为空，则表示不关心。其中支持的异常条件只有两个（UNP128页，没看懂）。这三个参数都是值-结果参数，当函数返回时，这三个参数会被修改。所以每次调用`select`时需要重置这三个参数。
>   > * `maxfdp1`指定待测试的最大文件描述符加1，从`0`一直到`maxfdp1-1`文件描述符将被测试
> * 描述符就绪的条件（**UNP130页**）
> * 对于描述符集的实现，一般情况下是使用整型数组实现的。第一个元素对应描述符**0-31**，第二个对应**32-63**，以此类推。一般情况下，`select`最大描述符数为1024。
> * `select`缺点：
>   > * 可监控的文件描述符集大小有限制，`sizeof(fd_set)`根据机器不同，这边的数值为128字节，说明可监控文件描述符为1024个
>   > * 每次调用`select`,都需要自己手动设置`fd_set`，从接口使用来说不方便，并且输入输出参数为一个值，还需要自己维护第三个变量
>   > * 每次调用`select`都需要将fd集从用户态拷贝到内核态，这边为128*3字节，虽然感觉上不大，但是拷贝次数太频繁
>   > * 每次不管是内核还是我们自己在使用的时候，都要遍历`fd_set`，开销也挺大的
> * [`select`实现原理](https://www.cnblogs.com/sky-heaven/p/7205491.html)
> * 当一个被监听的文件描述符被关闭时，其结果是不确定的。在Linux中，这种作法没有任何效果，即无法关闭文件描述符。（`man 2 select`）
> * 当监听集合超过1024时，会发生错误。[连接](https://blog.csdn.net/test1280/article/details/94436202)

## `poll`函数
> * 函数原型：`int poll(struct pollfd *fdarray, unsigned long nfds, int timeout)`
> * 头文件：`#include<poll.h>`
> * 函数返回值：若有就绪的描述符，则返回就绪描述符个数；若超时，则返回0；如出错返回-1。
> * 参数：
>   > * `fdarray`是一个指向`pollfd`结构体的指针，用来描述测试描述符和关注的事件。其中测试的条件由结构体中`events`成员指定；`revents`成员指定函数返回时相应描述符的就绪状态。
>   > * `nfds`指定数组元素的个数。
>   > * `timeout`指定等待的时长，单位为毫秒。**等于0**表示轮询，不阻塞进程；**大于0**表示阻塞一定的时长；`INFTIM`表示永远等待。
> * 当我们不再关心某一描述符时，可以将相应`pollfd`结构中的`fd`设为负值即可。
> * `events`和`revents`成员可用的常值见**UNP144页**。其中相应的出错标志不能在`events`中设置。只要相应条件发生，就会在`revents`中返回。
> * 关于可读可写的条件见**UNP145页**。
> * `poll`最主要的缺点与`select`相似，都需要在用户空间和内核空间大量复制描述符结构；并且用户和内核都需要遍历数组，这在监听文件描述符较多时是非常耗时的。
> * [`poll`底层实现](https://www.jb51.net/article/97777.htm)

## `epoll`函数
> * [`epoll`详解_1](https://blog.csdn.net/xiajun07061225/article/details/9250579)
> * [`epoll`详解_2](https://www.cnblogs.com/OnlyXP/archive/2007/08/10/851222.html)
> * [`epoll`详解_3](https://blog.csdn.net/daaikuaichuan/article/details/83862311)

## `Reactor`模式和`Proactor`模式
> * `Reactor`模式是一个事件驱动型编程模型。它处理事件的流程为：
>   > * 应用程序将自己关心的事件在`Reactor`上注册，并设置回调函数
>   > * `Reactor`等待事件发生
>   > * 当相应事件发生时，回调第一步注册的回调函数
> * 关键组件：
>   > * `Event`(事件):用于所关心的事件，在网络I/O中，即关注文件描述符是否可读可写。
>   > * `Reactor`(反应器):提供事件的注册和注销功能；并且运行事件循环，当相应事件发生时，调用回调函数
>   > * `Event Demultiplexer`(事件多路分发机制):通常是操作系统提供的I/O多路复用机制
>   > * `Event Handler`(事件处理程序):当相应事件发生时，`Reactor`回调该程序来处理。
> * 优点：
>   > * 实现相对简单
>   > * Reactor实现相对简单，对于耗时短的处理场景处理高效； 
>   > * 操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性； 
>   > * 事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁； 
>   > * 事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，
>   > * 可扩展性好，可以通过增加Reactor实例来充分利用CPU
>   > * `reactor`本身与具体事件的处理逻辑无关，有很高复用性
>   > * 采用非阻塞式IO，不会被阻塞，响应快。
> * `Reactor`与`Proactor`的区别在于IO的过程是同步还是异步。


##  网络编程中函数阻塞与非阻塞
> * 对于`accept`,`read`,`write`等，调用这些函数是否会阻塞主要取决于相应的文件描述符（套接字）是否是阻塞的，如果文件描述符是阻塞式的，则调用这些函数会阻塞；如果不是则为非阻塞。
> * 对于`select`,`poll`,`epoll`等，调用这些函数是否会阻塞主要取决于是否有相应文件描述符就绪，如果没有就阻塞，否则不阻塞。这些函数是否会阻塞与文件描述符是否是阻塞式I/O没有关系。

##