## Linux平台下C++代码编译过程
> * **预处理**：该阶段主要是对源文件进行预处理，主要是**替换宏定义**、**处理#include指令**、**预编译指令**等，生成 **.i** 文件。
> * **编译**：主要对源文件进行**词法分析**、**句法分析**等，生成 **.s**的汇编文件
> * **汇编**：该过程就是对**汇编代码翻译成机器指令**，生成二进制的目标文件，以 **.o**结尾。
> * 编译过程结束后，要想生成可执行程序前，还要进行链接，其中链接又分为**静态链接**和**动态链接**。
> * **静态链接**：简单说就是把不同 **.o**文件凑到一起。由于代码中可能包含了很多其他的库，这种方法导致可执行文件非常大。并且如果有多个程序都包含同一段代码，那么在执行时，内存中将有这段代码的多个副本。另一个缺点就是每当库函数的代码改变时，源程序代码就需要重新编译链接，更新麻烦。静态链接的优点就是由于已经具备了执行的所有代码，所以执行速度很快。
> * **动态链接**：动态链接时，当源代码使用了库函数的代码，其不是将库函数代码包含进来，还是存储了一些库函数的信息。等待真正运行程序时，库函数才被加载到内存。动态链接的优点就是当多个程序依赖同一段代码时，内存只存在一份副本。并且当库函数更新时，只要重新编译库函数的源码就可以了，而不需要重新编译自己的源码。缺点就是每次执行程序才进行连接，有一定性能损失。

## 进程和线程区别
> * 进程是资源分配的单位，而线程是CPU调度的最小单位
> * 每个进程都有自己独立的地址空间。当建立进程时，内核会为其分配地址空间，并且建立数据维持其代码段、数据段、堆、栈等，这些操作非常耗时；而同一个进程中的线程共享进程的地址空间，所以创建和销毁线程的代价远比进程的代价要小，同时线程的调度也比进程调度要小。
> * 由于进程的地址空间是独立的，所以进程间通信比较麻烦，一般需要特殊的IPC方式；而线程之间共享进程空间，所以可以共享全局变量、静态变量等，通信比较容易。但是正因为数据共享，所以在多线程编程中需要注意数据的互斥访问。
> * 多进程的程序相对来说更加健壮，一个进程的退出一般不会影响其它进程；而多线程程序中，如果一个线程崩了，整个进程都会死掉。

## 编译型语言和解释性语言
> * 编译型语言需要在运行前进行编译，生成可执行文件后才能运行；而解释型语言不需要在运行前编译，而是在运行时由解释器翻译成二进制代码。
> * 编译型语言由于已经提前生成了二进制代码，所以运行速度较快；而解释型语言在运行时才翻译，所以运行速度较慢。

## 线程安全
> * 线程安全就是在多线程编程中，利用加锁机制，保证多个线程正确访问和操作同一个数据。每个线程在访问数据之前，都需要获得锁；当数据访问结束时，需要释放锁。如果锁被其它线程占用，那么自己需要阻塞，以等待占用锁的线程释放锁。

## 互斥量
> * 主要用来解决线程互斥问题。当一个线程需要获取一个互斥资源时，需要先获得互斥量。同一时刻只允许一个线程获得互斥量，而其它任何试图获取互斥量的线程都会被挂起。在访问完互斥资源后释放互斥量，以供其它线程使用。

## 信号量
> * 信号量是进程之间进行同步和互斥的一种机制，它运行同一时刻多个进程访问同一资源，但是对进程的数量有一定限制。
> 信号量上主要有两个操作，**P**操作和**V**操作
> 二元信号量其实就是互斥量，用于进程之间的互斥；而多元互斥量可用于进程之前的同步。

## 进程状态
> * 进程主要有三种状态
> * **运行态**：即当前CPU正在运行的进程就是处于运行态。
> * **就绪态**：除了没有获得CPU外，其它任何运行进程的条件都已经满足，这样的进程处于就绪态。处于就绪态的进程随时可能被CPU调度。
> * **阻塞态**：进程由于需要获取某个资源，现在还无法运行。就是CPU空闲，也无法运行。
> * 进程状态的相互转换
>   > * **运行态 -> 就绪态**：进程的时间片被用完，或者被高优先级抢占
>   > * **就绪态 -> 运行态**：进程被CPU调度
>   > * **运行态 -> 阻塞态**：正在运行的进程需要获得某个资源，而该资源无法立即得到。例如进程需要进行I/O或者需要获得互斥锁。
>   > * **阻塞态 -> 就绪态**：进程等待的事件到来，已经具备了可运行的条件。

## 进程上下文切换和线程上下文切换
> * 进程切换主要由两部组成
>   > * 切换页目录以使用新的地址空间（也就是页表）
>   > * 切换硬件上下文，包括程序计数器、程序状态字等。
> * 对于线程切换来说，由于不同的线程共享内存空间，所以不需要切换页目录，只需要切换硬件上下文。
> * 进程切换还有一个隐藏的损耗就是造成缓存机制的失效，包括页表缓存TLB和内存缓存，进程切换将导致在一段时间内缓存全部失效，从而需要访问内存，这是相当低效的。
> * 对于用户态切换成内核态时，由于所以进程共享内核态，所以也不需要切换页表，只需要进行硬件上下文切换就行了。
> * 内核页表和进程页表。[链接](https://segmentfault.com/a/1190000012269249?utm_source=tag-newest)

## 大端模式和小端模式
> * **大端模式**：即数据高位存储在字节低位，而数据低位存储在字节高位。大端模式符合人的阅读习惯。
> * **小端模式**：数据高位存储在字节高位，而数据低位存储在字节低位。由于处理器读取数据是从低地址向高地址开始读，所以小端模式跟适合处理器处理数据。
> * 怎么测试主机是打断模式还是小端模式？
>   > 定义一个整数，赋值为0x01020304，然后定义一个char指针，指向整数；然后输出char的内容。如果输出顺序为1，2，3，4，那么就是大端；如果输出顺序为4，3，2，1则为小端。

## 死锁与饥饿
> * **死锁**：在一组进程中，每一个进程都在无限等待另一个进程占有的资源，而导致所有进程都无法运行，这种现象就叫出现死锁。
> * **饥饿**：由于高优先级进程的持续抢占，导致低优先级的进程一直无法得到所需要的资源，低优先级的进程就叫出现了饥饿现象。

## 产生死锁的必要条件：
> * **互斥使用**：每一个资源都是能给一个进程使用。
> * **占有且等待**：在持有原来资源不释放的条件下，请求新的资源
> * **不可抢占**：资源的申请者不能强行抢占资源，只能等待资源持有者主动释放资源。
> * **循环等待**：若干进程形成一个循环等待队列。

## 解决死锁的基本方法
> * 预防死锁
>   > * 资源一次性分配，并且如果由任何一个资源无法获得，则释放所有持有的资源等待（破环占有且等待条件）
>   > * 当进程申请一个资源时，可以根据进程优先级进行抢占资源。（破坏不可抢占条件）
>   > * 在进行资源分配时，每个进程都根据相同的顺序进行资源分配。（破坏循环等待条件）

## 解除死锁的方法
> * **剥夺资源**：从其他进程中剥夺资源分配给死锁进程，从而解除死锁状态。
> * **撤销进程**：逐一撤销死锁进程，直到有足够的资源可以使用，从而接触死锁状态。

## 堆和栈的区别
> * **管理方式**：栈是由编译器管理的，由编译器自动申请和释放；而堆是由程序主动申请和释放的，可能造成内存泄漏
> * **存储内容**：栈中一般存储局部变量、函数参数和函数返回值，而堆中一般存储动态对象。
> * **空间大小**：栈空间是一块连续的内存空间，其大小是提前分配好的；而堆是不连续的内存空间，通常其大小主要是受限于虚拟内存。
> * **碎片问题**：对于堆来说，频繁的申请动态内存势必会造成内存空间不连续，从而导致内存碎片，而栈不会造成内存碎片。
> * **分配效率**：系统中有一个专门记录空闲地址的链表，当需要分配堆时，需要遍历链表，从而找到一个合适的地址来分配堆，所以分配效率低；而栈是机器系统提供的数据结构，有专门存储栈地址的寄存器，专门的栈操作指定，效率较高。
> * **生长方向**：栈是从高地址向低地址方向生长，而堆是从低地址向高地址方向生长。

## 虚拟内存的优势
> * 每个进程的虚拟内存都是从0开始的，并且使一段连续的内存空间，从而为程序的编写提供了方便。
> * 通过虚拟内存，可以运行实际需要的物理内存大于可用的物理内存的进程。
> * 保护每个进程地址空间的独立性，确保每个进程只会访问自己的内存空间，而不会有意或者无意的破获其它进程的地址空间。

## 页面调度算法
> * FIFO
> * 第二次机会FIFO
> * LRU(Least Recently Used: 最近最少使用)

## 进程间通信方式
> * **(无名)管道**：
>   > * 可以把管道看成一种特殊的文件，但是该文件只存在于内存中，会随着进程消失而消失。
>   > * 管道一种半双工的工作方式，如果需要通信双发互发数据，则需要创建两个管道。
>   > * 管道只能用于有亲属关系进程之间的通信。
> * **FIFO(有名管道)**：
>   > * FIFO是文件，存在于文件系统，可以通过路径名来标识一个FIFO。
>   > * 也是半双工通信
>   > * 可用于任何进程之间的通信。
> * **消息队列**：
>   > * 消息队列就是由一个存放消息的列表组成，存放在内核中。每个消息队列由一个标识符来标识。
>   > * 消息队列是面向消息的，接收和发送一个完整的消息。
>   > * 消息队列是独立于进程，当进程结束时，消息队列不会自动撤销，需要用户进程主动撤销。
>   > * 消息队列不一定按照先入先出的顺序访问，可以按照消息类型进行查询。
> * **信号量**；
>   > * 主要用于进程之间的同步和互斥。
> * **共享内存**：
>   > * 多个进程将一段物理内存都连接到自己的虚拟地址空间，每个进程对共享内存的操作都会影响其它进程，从而达到进程间通信的目的。
>   > * 共享内存相当于多个线程共享全局变量，当多个进程同时对共享内存进行读写时需要注意同步和互斥。
>   > * 共享内存可用于任何进程间通信，效率较高。
> * **信号**：
>   > * 信号用来通知进程发生了某种时间，是在软件层的模拟中断。
>   > * 每个进程可以通过注册信号处理函数来实现对特定事件的处理。
> * **套接字**：
>   > * 套接字最大的优势就是可用于不同主机进程之间的通信。

## 僵尸进程、孤儿进程和守护进程
> * **僵尸进程**：在进程结束时，除了释放大部分资源以后，还会再内核中留下少量信息以后父进程来获取，这种状态的进程就是僵尸进程。僵尸进程会占用少量内存，同时占用PID。僵尸进程需要父进程主动来回收。
> * **孤儿进程**：每个进程都有一个父进程，然而当一个进程的父进程提前结束了，那么它就变成了孤儿进程。孤儿进程会被init进程收养，由init进程回收其状态。
> * **守护进程**：守护进程是一类特殊的后台进程，不予任何终端关联，用来完成某些特定的功能。守护进程一般从系统启动开始运行，一直持续到系统结束。守护进程大部分时间都在睡眠，当特定时间发生时，操作系统会唤醒守护进程来处理时间，处理完以后继续睡眠。
> * **创建守护进程的步骤**：[链接](https://www.cnblogs.com/diegodu/p/6100689.html)
>   > * 创建子进程，并且让父进程结束
>   > * 子进程调用setid创建新的会话
>   > * 子进程调用chdir函数，将根目录设置成自己的工作目录
>   > * 子进程调用umask函数，设置进程的umask为0；
>   > * 子进程关闭所有文件描述符。

## 协程

## 内存对齐
>  * **什么是内存对齐**
>   > * 虽然计算机可以按字节访问任何字节的数据，但是并非按逐字节大小读写内存，而是以2，4，8等倍数来读写数据，这就要求对基本数据类型的存储地址做出一些限制，这就是内存对齐。
> * 内存对齐**最大的好处就是提高内存的系统性能**，因为可以让系统按照多个字节来对数据进行操作，而不是每个字节。
> * **对齐准则**
>   > * 有效对齐值（对齐单位）：每个特定平台上的编译器都有自己的默认“对齐系数”，例如gcc中默认为4，可以通过预编译指令`#pragma pakc(n)`来改变默认对齐系数。有效对齐值取成员数据大小和默认对齐系数中的较小者。
>   > * 所有成员变量相对于首地址的偏移量必须为整数倍的有效对齐值，如果不满足，则填充字节。
>   > * 结构体的总大小为结构体最大成员和对齐系数中较小者的整数倍，如果不满足，则填充字节。
> * [参考链接](https://zhuanlan.zhihu.com/p/30007037)