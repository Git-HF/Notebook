# 引言
学习muduo网络库的笔记，可能主要记录一些unix函数的用法
- - -
### 1. `CLOCK_MONOTONIC`与`CLOCK_REALTIME`的区别：
   - `CLOCK_MONOTONIC`是绝对时间，指的是从系统启动到现在的时间，更改系统时间对此没有影响
   - `CLOCK_REALTIME`是相对时间，指的是从1970.1.1零点到现在的时间，更改系统时间会影响此值  

### 2. `timerfd`系列函数的使用
- `timerfd`是Linux系统提供给用户的定时器接口，它是基于文件描述符的，通过文件描述符可读来进行超时通知（当文件描述符不可读时，返回错误），可被用于`select/poll`中。
- 
### 3. 对于`ssize_t read(int fd, void* buf, size_t nbytes)`系统调用，如果`nbytes=0`,则函数什么时候返回`0`,什么时候返回`1`?
- 简单来说，只有函数不返回-1的情况下，函数才返回0；可以把函数返回0看作是进行了正常的I/O流程，只不过只读了0字节（读到文件尾，返回0，也看做是进行正常的I/O过程）。当函数返回-1时表示有某种东西出错了，没办法完成正常的I/O。
- 对于低速系统调用（可能会永久阻塞的系统调用），例如对于 ***sockfd*** 来说：
  ```c++
  int sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
  char c;
  int ret;

  ret = read(sock_fd, &c, 0);
  printf("%d\n", ret);            //阻塞式套接字，nbytes=0，返回0

  ret = read(sock_fd, &c, 1);
  printf("%d\n", ret);            //阻塞式套接字，nbytes=1，阻塞

  int flags = fcntl(sock_fd, F_GETFL, 0);
  flags |= O_NONBLOCK;
  fcntl(sock_fd,F_SETFL,flags);

  ret = read(sock_fd, &c, 0);
  printf("%d\n", ret);            //非阻塞式套接字，nbytes=0，返回0

  ret = read(sock_fd, &c, 1);
  printf("%d\n", ret);            //非阻塞式套接字，nbytes=1, 返回-1  
  ```
- 对于 ***普通文件***（有足够的字节）来说（其实对于普通文件来说，阻塞式和非阻塞式的影响不大）：
  ```c++
  int file_fd = open("file1, O_RDONLY");
  char c;
  int ret;

  ret = read(file_fd, &c, 0);
  printf("%d\n", ret);            //阻塞式文件描述符，nbytes=0，返回0

  ret = read(file_fd, &c, 1);
  printf("%d\n", ret);            //阻塞式文件描述符，nbytes=1，返回1

  int flags = fcntl(file_fd, F_GETFL, 0);
  flags |= O_NONBLOCK;
  fcntl(file_fd,F_SETFL,flags);

  ret = read(file_fd, &c, 0);
  printf("%d\n", ret);            //非阻塞式文件描述符，nbytes=0，返回0

  ret = read(file_fd, &c, 1);
  printf("%d\n", ret);            //非阻塞式文件描述符，nbytes=1, 返回1
  ```
- 对于`timer_fd`来说，可以使用`select/poll/epoll`来测试其可读性，但是如果使用`read`来读取数据，会一直返回 ***-1***
 