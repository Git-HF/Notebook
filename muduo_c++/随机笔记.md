# 引言
学习muduo网络库的笔记，可能主要记录一些unix函数的用法
- - -
### 1. `CLOCK_MONOTONIC`与`CLOCK_REALTIME`的区别：
   - `CLOCK_MONOTONIC`是绝对时间，指的是从系统启动到现在的时间，更改系统时间对此没有影响
   - `CLOCK_REALTIME`是相对时间，指的是从1970.1.1零点到现在的时间，更改系统时间会影响此值  

### 2. `timerfd`系列函数的使用
- `timerfd`是Linux系统提供给用户的定时器接口，它是基于文件描述符的，通过文件描述符可读来进行超时通知，可被用于`select/poll`中。
- `int timerfd_creat(int clockif, int flags)`函数
    * 用来创建一个定时器，并且返回一个文件描述符
    * 参数`clockid`：有两个值`CLOCK_MONOTONIC`和`CLOCK_REALTIME`，解释见 ***上一项***；
    * 参数`flags`：可以是0，或者是`TFD_CLOEXEC/TFD_NONBLOCK`；
- `int timerfd_settime(int fd, int flags, const struct itimerspec* new_value, struct itimer spec* old_value)`函数
  * 用来启动或者关闭`fd`指定的定时器，
  * `fd`：即`timefd_create`的返回值，用来指定一个定时器；
  * `flags`：`0`（或者`TFD_TIMER_ABSTIME`）表示相对时间，即第三个参数表示一个延时时间，`1`表示绝对时间，即第三个参数是当前时间+延时时间，当前时间可以通过`clock_gettime`获得。注意当前时间+延时时间时，注意`timespec`结构体中的`tv_nsec`成员不要超过1000000000，否则在`tv_sec`加1（进位加一）
  * `new_value`和`old_value`：分别表示新设置的定时器时间和返回上次定时器时间，其中`old_value`可以设置为`NULL`，表示不关心上次的定时器。
  * 介绍一下`struct itimerspec`：
    ```c++
    struct itimerspec {
      struct timespec it_interval;
      struct timespec it_value; }
    ```
	- `it_value`：表示第一次超时的时间;
	- `it_interval`：表示后续周期性超时的时间。
	- 其中`timespec`：
      ```c++
      struct timespec{
          time_t tv_sec;    //表示秒
          long tv_nsec;}    //表示纳秒
      ```
  * 返回值若调用成功，则返回0
- `int timerfd_gettime(int fd, struct itimerspec* curr_value)`函数
  * 获取距离下次超时剩余的时间
  * `curr_value`表示距离下次超时的时间，若为0则定时器被解除。该字段永远是相对值，无论`TFD_TIMER_ABSTIME`是否被设置。
- 不论阻塞式还是非阻塞式，不论是否到达定时时间，使用`read`读取`timerfd`都返回-1；
- 不论阻塞式还是非阻塞式，到达定时之前，`poll`都立即返回0（即使是阻塞式，也立即返回0）；在到达定时后，`poll`返回1；（对于`epoll`来说，可能有水平触发和边沿触发之分）

### 3. 对于`ssize_t read(int fd, void* buf, size_t nbytes)`系统调用，如果`nbytes=0`,则函数什么时候返回`0`,什么时候返回`1`?
- 简单来说，只有函数不返回-1的情况下，函数才返回0；可以把函数返回0看作是进行了正常的I/O流程，只不过只读了0字节（读到文件尾，返回0，也看做是进行正常的I/O过程）。当函数返回-1时表示有某种东西出错了，没办法完成正常的I/O。
- 对于低速系统调用（可能会永久阻塞的系统调用），例如对于 ***sockfd*** 来说：
  ```c++
  int sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
  char c;
  int ret;

  ret = read(sock_fd, &c, 0);
  printf("%d\n", ret);            //阻塞式套接字，nbytes=0，返回0

  ret = read(sock_fd, &c, 1);
  printf("%d\n", ret);            //阻塞式套接字，nbytes=1，阻塞

  int flags = fcntl(sock_fd, F_GETFL, 0);
  flags |= O_NONBLOCK;
  fcntl(sock_fd,F_SETFL,flags);

  ret = read(sock_fd, &c, 0);
  printf("%d\n", ret);            //非阻塞式套接字，nbytes=0，返回0

  ret = read(sock_fd, &c, 1);
  printf("%d\n", ret);            //非阻塞式套接字，nbytes=1, 返回-1  
  ```
- 对于 ***普通文件***（有足够的字节）来说（其实对于普通文件来说，阻塞式和非阻塞式的影响不大）：
  ```c++
  int file_fd = open("file1, O_RDONLY");
  char c;
  int ret;

  ret = read(file_fd, &c, 0);
  printf("%d\n", ret);            //阻塞式文件描述符，nbytes=0，返回0

  ret = read(file_fd, &c, 1);
  printf("%d\n", ret);            //阻塞式文件描述符，nbytes=1，返回1

  int flags = fcntl(file_fd, F_GETFL, 0);
  flags |= O_NONBLOCK;
  fcntl(file_fd,F_SETFL,flags);

  ret = read(file_fd, &c, 0);
  printf("%d\n", ret);            //非阻塞式文件描述符，nbytes=0，返回0

  ret = read(file_fd, &c, 1);
  printf("%d\n", ret);            //非阻塞式文件描述符，nbytes=1, 返回1
  ```
- 对于`timer_fd`来说，可以使用`select/poll/epoll`来测试其可读性，但是如果使用`read`来读取数据，会一直返回 ***-1***，即调用出错。

### 4. 
 