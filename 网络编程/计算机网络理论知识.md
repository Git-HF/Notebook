### 1. TCP建立连接三次握手过程
> * 最初客户端和服务端都处于**CLOSE**（TCP状态转换的一种）状态。
> * 服务端进程先创建**TCB**，进入**LISTEN**状态，准备接收来自客户端的连接；
> **传输控制块TCB(Transmission Control Block)**，主要存储每一个TCP连接的重要信息，
> 例如TCP连接表；指向接受和发送缓冲区的指针；指向重传队列的指针；保存发送和接受的序号
> * 客户端进程也建立**TCB**，然后发送连接请求报文段。该报文段中同步位**SYN=1**，
> 并且随机产生初始序号**seq=x**。虽然该报文段**不能携带数据**,但是需要**消耗掉一个序号**，
> 此时客户进程进入**SYN-SENT**状态。
> * 服务端进程接收到客户端建立连接请求后，如果同意建立请求，则发送确认报文段。在该报文段中同> 步位**SYN=1**、确认位**ACK=1**，同时确认序号**ack=x+1**，表明下一次接收报文的序列号为
> **x+1**；同时表明自己本次序列号为**seq=y**。该报文段也**不能携带数据**，但是**消耗一个
> 序列号**。此时服务端进程进入**SYN_RCVD**状态。
> * 客户端进程接收服务端的确认报文后，还需要再再向服务端发送一个确认报文。该报文中，
> 确认位**ACK=1**，确认序列号**ack=y+1**，自己的序列号**seq=x+1**。该报文段可以携带
> 数据。如果未携带数据则不消耗序列号，即下次发送数据的序列号依然是从**seq=x+1**开始。
> 此时客户端进程进入**ESTABLISHED**状态。
> * 当服务端接收到客户端的确认报文后，服务端也进入**ESTABLISHED**状态。
> * 自此TCP连接建立完毕。

### 2. TCP建立连接的过程为什么不能是两次？
> * 总的来说是为了防止服务器白白等待浪费资源。
> * 如果采用两次握手，想像如下的场景：客户端希望和服务端建立连接，在客户端第一次发送请求连接报文后（**SYN=1**
> 的报文），由于网络拥塞，该报文暂时未到达服务端；客户端在规定时间范围内未收到服务端发来的确
> 认报文，超时重传机制使客户端发送了第二个请求连接报文，该报文顺利到达，并且与服务端建立
> 连接，互传数据，关闭连接。如果此时第一次发送的被阻塞的请求连接报文所处网络通畅了，被顺利
> 发送至服务端，服务端以为这是客户端重新发起的请求连接，并不知道这其实是一个已经失效的报文
> 段。此时服务端同意建立新的连接，并且返回该连接的确认报文。当
> 客户端收到该确认报文时，因为客户端并没有发起建立连接的请求，所以客户端不会理睬，也不会
> 向服务端发送任何数据。这就导致服务端认为建立了一个新的连接，而一直等待客户端发送数据，
> 白白浪费资源。如果采用三次握手，客户端对于服务端发来的确认请求不予理睬，服务端收不到
> 客户端的确认，即不会建立新的连接，避免了服务端的资源浪费。

### 3. TCP建立连接为什么不能是四次？
> * 三次握手已经满足需要，可以正确建立连接，使用四次就显得多余了

### 4. TCP断开连接四次挥手过程
> * 一般情况下，由客户端主动断开连接，服务端被动断开连接，此时两者都处于**ESTABLISHED**
> 状态。
> * 当发送完所有数据时，就发送连接释放报文请求断开连接。该报文中终止位**FIN=1**，序列号
> **seq=u**（等于前面已经发送的最后一个字节数据序列号加1）。客户端进入**FIN-WAIT-1**
> 状态。该报文段不能携带数据，但是消耗一个序列号。
> * 服务端接收客户端的释放连接报文，返回一个确认报文。该报文中确认位**ACK=1**，确认序列号
> **ack=u+1**，同时设置自己的序列号**seq=v**（等于前面已经发送数据最后一个字节编号加一）。
> 此时服务端进程进入**CLOSE-WAIT**状态。服务端通知高层的应用进程，客户端至服务端的连接
> 已经释放，此时的状态被称为**半关闭状态**，即客户端已经没有要发送的数据了，但是服务端
> 依然可以发送数据，并且客户端可以接受。
> * 当客户端收到服务端的确认报文后，进入**FIN-WAIT-2**状态。在此期间，客户端还接受
> 服务端发来的数据。
> * 当服务端将最后的数据发送完毕后，服务端发送连接释放报文。该报文终止位**FIN=1**，假设
> 自己的序列号**seq=w**（在半关闭状态，服务端可能又发送了一些数据，所以序列号会改变，不
> 再是**seq=v**）。确认序列号依然是**ack=u+1**。服务端进入**LAST-ACK**状态。
> * 客户端接收到服务端的连接释放报文，返回确认报文。该报文确认位**ACK=1**，确认号
> **ack=w+1**；自己的序列号**seq=u+1**。此时客户端进入**TIME-WAIT**状态，此时TCP连接还
> 没有完全释放，必须等待**2\*MSL(Maximum Segment Lifetiem，最长报文段寿命)**时间后，
> 客户端撤销相应的**TCB**后，连接才完全释放，客户端进入**CLOSED**状态。
> * 服务端接收到客户端的确认报文后，服务端撤销**TCB**， 结束本次TCP连接，
> 进入**CLOSED**状态。

### 5. **TIME-WAIT**的意义？（或者为什么主动释放连接的一方需要等待2\*MSL时间）
> * **为了可靠的实现TCP全双工连接的终止**。如果没有**TIME-WAIT**机制，客户端在发送完
> 确认报文后立马进入**CLOSED**状态，碰巧这个确认报文丢失了；服务端的重传机制会重新发送
> 连接释放请求，而此时客户端并没有与之对应连接，所以客户端会响应一个**RST**，让服务端按非
> 正常流程终止TCP连接。所以**TIME-WAIT**机制是为了可能重传那个丢失的ACK。
> * **为了允许老的重复的分节在网络中消逝**。假设没有**TIME-WAIT**状态，在TCP连接正常断开
> 后，可能在客户端和服务端之间立刻创建相同的TCP连接（对于客户端和服务端，IP地址和端口号与刚
> 刚断开的连接完全一样），那么由于网络阻塞滞留在网络中的分节就可能会被重新发送到客户端或者
> 服务端，而这个分节本应该是一个失效的分节。如果等待**2\*MSL**后，这段时间足以让某一个
> 方向上的分节存活MSL后被丢弃，另一个方向上的分节分节最多存货MSL也被丢弃。这样就能保证
> 每次新建TCP连接时，来自旧连接重复的分节在网络中消失。

### 6. **TIME-WAIT**的时间为什么是2\*MSL，能不能是小于2\*MSL的值？
> 等待第一个MSL是为了让自己发送的ACK要么被接收，要被消失在网络中；等待的第二个MSL是为了
> 防止在对端接收ACK之前的那一瞬间，对端可能重传FIN报文从网络中消失。虽说TIME-WAIT状态有
> 两个目的，但是这段时间具体为多长，主要为了达成第二个目的而设计的。

### 7. TCP保活机制
> 假如有这样的场景，客户端和服务端已经建立了TCP连接，可是客户端**主机突然奔溃了**（是主机，而不是进程），如果没有相应的措施，那么服务器进程可能一直等待客户端发送数据，造成服务端资源浪费。TCP使用保活计时器来处理这种情况。每次服务端收到客户端的报文后，服务端会重新设置保活计时器，通常设置为两小时；如果两小时之内服务端都没有收到来自客户端的消息，服务器就发送一个探测报文段，以后每隔75分钟发送一次；连续发送10次后客户仍然没有回应，则服务端认为客户端发生故障，主动关闭连接。

### 8. 建立TCP连接后，异常情况分析
> a. 建立TCP连接后，如果通信双发有一方的**进程突然奔溃了**：
> > 当本地端的进程突然崩溃了，作为进程终止处理的一部分，所有打开的文件描述符都会被关闭，这样导致向对端发送一个FIN请求释放连接的报文，对端回应一个ACK确认报文。由于对端不知道本地端的进程已经结束，可能会向本地端发送数据，而此时本地端已经没有与之相对应的TCP连接，所以本端会回应一个RST复位报文（如果对已经接受了RST的套接字继续执行写操作，则会产生**SIGPIPE**信号；该信号的默认行为是终止进程。如果一个进程中有多个套接字，该信号的递交无法告诉我们是哪个套接字发生了错误。如果我们需要知道是哪个套接字发生了错误，可以选择忽视该信号，然后相应的`write`函数会返回**EPIPE**）。  

> b. 建立TCP连接后，如果通信双方有一方**主机奔溃了**；
> > 当本地端主机突然奔溃了，参考**TCP保活机制**。  